---
title: C 语言入门实录 二
date: 2017-01-21 11:29:00
categories: C
tags: [C,学习记录]
---

C语言中的类型分为一下几种

| 序号 | 类型和描述                                                     |
| ---- | -------------------------------------------------------------- |
| 1    | 基本类型：算术类型 ，整数类型和浮点类型                        |
| 2    | 枚举类型：也是算术类型，但是是一些离散固定的整数类型           |
| 3    | void类型：表明没有可用的值                                     |
| 4    | 派生类型：指针类型，数组类型，结构类型，函数类型以及共用体类型 |

------------

## 整数类型

| 类型           | 存储大小（1个字节(bit)占8位[bits]） | 值的范围（由二进制得出）                             |
| -------------- | ----------------------------------- | ---------------------------------------------------- |
| char           | 1字节                               | -128~127 或者 0~255                                  |
| unsigned char  | 1字节                               | 0~255                                                |
| signed char    | 1字节                               | -128~127                                             |
| int            | 2字节(16位系统)或4字节(32/64位系统) | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2字节(16位系统)或4字节(32/64位系统) | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2字节                               | -32,768 到 32,767                                    |
| unsigned short | 2字节                               | 0 到 65,535                                          |
| long           | 4字节                               | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4字节                               | 0 到 4,294,967,295                                   |

------------

<!-- more -->

但是C语言的取值范围是如何计算的出来的呢？

> 二进制数据在计算机中存储的是补码
> 正数的补码等于原码,负数补码需要在符号位之后取反+1

如果以最高位为符号位，二进制原码最大为0111111111111111=2的15次方减1=32767
最小为1111111111111111=-2的15次方减1=-32767
此时0有两种表示方法，即正0和负0：0000000000000000=1000000000000000=0
所以，二进制原码表示时，范围是-32767～-0和0～32767，因为有两个零的存在，所以不同的数值个数一共只有2的16次方减1个，比16位二进制能够提供的2的16次方个编码少1个。
但是计算机中采用二进制补码存储数据，即正数编码不变，从0000000000000000到0111111111111111依旧表示0到32767，而负数需要把除符号位以后的部分取反加1，即-32767的补码为1000000000000001。
到此，再来看原码的正0和负0：0000000000000000和1000000000000000，补码表示中，前者的补码还是0000000000000000，后者经过非符号位取反加1后，同样变成了0000000000000000，也就是正0和负0在补码系统中的编码是一样的。但是，我们知道，16位二进制数可以表示2的16次方个编码，而在补码中零的编码只有一个，也就是补码中会比原码多一个编码出来，这个编码就是1000000000000000，因为任何一个原码都不可能在转成补码时变成1000000000000000。所以，人为规定1000000000000000这个补码编码为-32768。
所以，补码系统中，范围是-23768～32767。
因此，实际上，二进制的最小数确实是1111111111111111，只是二进制补码的最小值才是1000000000000000，而补码的1111111111111111是二进制值的-1

当然，如果你不确定当前每个类型占的自己数的话，可以使用一下代码来打印一下

```C
#include <stdio.h>

int main()
{

	printf("int 存储的字节大小为: %lu \n",sizeof(int));

	return 0;
}
```

## 浮点类型

| 类型        | 存储大小（1个字节(bit)占8位[bits]） | 值的范围（由二进制得出） | 精度      |
| ----------- | ----------------------------------- | ------------------------ | --------- |
| float       | 4 字节                              | 1.2E-38 到 3.4E+38       | 6 位小数  |
| double      | 8 字节                              | 2.3E-308 到 1.7E+308     | 15 位小数 |
| long double | 16 字节                             | 3.4E-4932 到 1.1E+4932   | 19 位小数 |

想要用float的函数和宏就需要引入float相关的函数定义

```C
#include <stdio.h>
#include <float.h> /** float头部 **/

int main()
{
	printf("float 最大存储的字节为 %lu \n",sizeof(float));

	printf("float 最小值为 %E\n",FLT_MIN);

	printf("float 最大值为 %E\n",FLT_MAX);

	printf("精确度 %d\n",FLT_DIG);

	return 0;
}

```

## void类型

指定没有可用的值

| 序号 | 类型与描述                                                                                                                                                   |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1    | 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);                                    |
| 2    | 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);                                                             |
| 3    | 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 |
