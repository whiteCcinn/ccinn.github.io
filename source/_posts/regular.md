---
title: 【正则表达式】- 分组概念
date: 2018-03-12 13:56:00
categories: [正则]
tags: [正则]
---

正则我们经常用，但是对于几个特殊的用途，可以记录一下。

- `(exp)` 匹配 exp,并捕获文本到自动命名的组里

- `(?<name>exp)` 匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?'name'exp)

- `(?P<name>exp)` 和 `(?<name>exp)`一个意思

- `(?:exp)` 匹配 exp,不捕获匹配的文本

- `(?=exp)` 匹配 exp 前面的位置

- `(?<=exp)` 匹配 exp 后面的位置

- `(?!exp)` 匹配后面跟的不是 exp 的位置

- `(?<!exp)` 匹配前面不是 exp 的位置

- `(?#comment)` 这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释

<!-- more -->

## 例子

比如

```JS
var m = "abcabc".match(/(?:a)(b)(c)/)
//结果 ["abc", "b", "c"]
// m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a
// m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence
// m[2] 是捕获组2，即(c)匹配到的
```

如果这样

```JS
var m = "abcabc".match(/(a)(b)(c)/)
//结果 ["abc", "a", "b", "c"]
```

第一小题应该是这样的正则表达式

```JS
/(\w)((?=111)(1))+/
```

这里有一个知识点 zero-width positive lookahead，零宽断言，正向前瞻（反正我记不住
意思是(?=X)匹配某个位置，右边（正向）是 X，它不真正匹配捕获子串。
看几个匹配的测试例子

```JS
/(\w)((?=111)(1))+/.test("1111") // true
/(\w)((?=111)(1))+/.test("2222") // false
```

匹配重复 4 次以上的字母或数字可以这么写

```JS
/(\w)(?=\1{3,})/.test("AAAAAAAA") //true
/(\w)(?=\1{3,})/.test("AAAB") //false
```
