---
title: 【Golang】- protobuf插件扩展开发详解
date: 2021-09-03 13:16:51
categories: [Golang]
tags: [Golang]
---

## 前言

最近，项目需要用到protobuf来定义消息，但是我们需要一个更灵活的代码片段，如何通过`proto`文件来创建自定义的代码呢？
可以通过proto的`plugin`对方式来自己是一个`proto-gen`。

在网上看了一些教程，发现有一些教程已经过时了，而且过于片面，没有把整套思想很好的说明。并且也有一些功能点并没有完全实现。
这里总结一下相关的内容，并且说一下最近实现的一个插件。

> 对于已经了解大概`proto`的人来说，相对简单，但是如果是`自定义option`呢？你又了解吗？

<!-- more -->

## 需求

```
// test.proto

syntax = "proto3";
package pb;
option go_package = "/;pb";

import "unknow.proto";

service ApiIMService {
    rpc RegisterDevice (ApiIMRegisterDeviceReq) returns (ApiIMRegisterDeviceResp) {
        option (unknow.api.http) = {
            method: "post"
            url: "/v1/im/register_device"
        };
    }
}

// 设备类型
enum ApiIMDeviceType {
    API_IM_UNKNOWN = 0;
    API_IM_Android = 1;
    API_IM_IOS = 2;
    API_IM_Window = 3;
    API_IM_MacOS = 4;
    API_IM_Web = 5;
}

message ApiIMRegisterDeviceReq {
    ApiIMDeviceType type = 1; // 设备类型
}

message ApiIMRegisterDeviceResp {
    int64 device_id = 1; // 设备id
}
```

我们看到这一个`proto`文件，常规的我就不说了。主要是看到`import "unknow.proto"`, `option (unknow.api.http)`

可以看到，我这里引入一个`unknow.proto`的文件。

我希望最终生成一个`api.unknow.go`的文件。里面的内容期待如下：

```go
// Copyright (c) 2021, whiteCcinn Inc.
// Code generated by protoc-gen-unknow. DO NOT EDIT.
// source: test.proto

package pb

type Api struct {
	Name   string
	Method string
	Url    string
}

func newApi(name, method, url string) *Api {
	return &Api{
		name, method, url,
	}
}

var (
	RegisterDeviceApi = newApi("RegisterDevice", "post", "/v1/im/register_device")
)

```

生成的文件，我可以在项目通过`pb.RegisterDeviceApi`拿到在`proto`定义好的API内容。

```
// unknow.proto

syntax = "proto3";

package unknow.api;

option go_package = "/;pb";

import "google/protobuf/descriptor.proto";

extend google.protobuf.MethodOptions {
    // See `HttpRule`.
    HttpRule http = 72295728;
}

message HttpRule {
    string url = 1;
    string method = 2;
}
```

- [google/api/annotations.proto](https://github.com/googleapis/googleapis/blob/master/google/api/annotations.proto)
- [google/api/http.proto](https://github.com/googleapis/googleapis/blob/master/google/api/http.proto)
- [google/protobuf/descriptor.proto](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto)

如果有了解过`google/api/annotations.proto` 和 `google/api/http.proto`的人应该不会陌生，当你需要用到`grpc-gateway`或者`proto-gen-swaager`的时候，都会有介绍到`option(goggle.api.http)`的用法。

这里我们看到`unknow.proto`的结构体，这就是一个简化版本。用于实现`自定义的option`用的。

### unknow.proto

对于基础的语法规则来说，我们来看剖析一下`unknow.proto`，常规的就不说了。

```
package unknow.api;

extend google.protobuf.MethodOptions {
    // See `HttpRule`.
    HttpRule http = 72295728;
}

message HttpRule {
    string url = 1;
    string method = 2;
}
```

对于`extend`的用法，我这里列一下官方的链接。

- [Custom Options](https://developers.google.com/protocol-buffers/docs/overview#customoptions)

我们看到这里，`extend google.protobuf.MethodOptions`。

代表着，我这里自定义个作用于`Method`的`option`。所以在真正的`proto`文件中，我就可以使用`unknow.api.option`的标签。也就是`option (unknow.api.http)`。

接着我们看到，这个option我们定义了一个元素，类型是`Message HttpRule`，命名为`http`，并且给它定义一个唯一的`Number`。

接着我们看到`HttpRule`，内部存在2个元素，一个是`string url` 和 `string method`，这意味着我们可以使用`独立行写法`：`option (unknow.api.http).url = "/v1/im/register_device"`，然后再下一行使用 `option (unknow.api.http).method = "post"`，一个完整的例如如下：

刚才说到，这是一个`method`的`option`，也就是我们这里定义的`rpc`下的 `option`。

```
service ApiIMService {
    rpc RegisterDevice (ApiIMRegisterDeviceReq) returns (ApiIMRegisterDeviceResp) {
        option (unknow.api.http).method = "post"
        option (unknow.api.http).url = "/v1/im/register_device"
    }
}
```

除了这个写法，我更推荐如下更简洁的写法，用`map`的写法：

```
service ApiIMService {
    rpc RegisterDevice (ApiIMRegisterDeviceReq) returns (ApiIMRegisterDeviceResp) {
        option (unknow.api.http) = {
            method: "post"
            url: "/v1/im/register_device"
        };
    }
}
```

这样子，我们就看懂了`test.proto`的内容了对吧。连贯起来，那么我们的这个`unknow.proto`就是用于实现`option(unknow.api.http)`。而`option(unknow.api.http)`的使用则在`test.proto`进行采用。

好了，有了定义的文件，那么接下来就是我们的重点了，如何编写一个实现`自定义代码的protobuf插件扩展`

### 扩展实现

首先，我们需要知道一点，我们在采用`protoc`对`proto`文件进行编译的时候，经常是执行类似如下代码：

```shell
protoc -I.:${GOGO_PROTOBUF} \
--gofast_out=plugins=grpc:./go-pb
```

由于这里我用的是`gogoprotobuf`，所以你会看到我这里的是`--gofast_out=plugins=grpc:./go-pb`，如果你是`protobuf`的官方的`proto-gen`的话，那么你这里应该是`--go_out=plugins=grpc:./go-pb`

这里我们需要注意的是什么呢，就是`插件二进制文件名`，这是有一定规则的，这是我之前在自定义git凭据文章中说明的一样，这二进制文件需要在你的环境变量中，否则你就需要通过`-I`来指定文件路径。然后命名规则为`proto-gen-xxx`，而这个`xxx`就是你的自定义的名字。在本例子中，我的扩展名字就是`proto-gen-unknow`。

因此，最终如果我要执行的话，那么就是执行如下命令：

```shell
protoc -I.:${GOGO_PROTOBUF} \
--unknow_out=./go-pb
```

