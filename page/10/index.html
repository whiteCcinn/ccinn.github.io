<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 10 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/23/nginx-load-balan/"><span>【Nginx】- 负载均衡</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/23/nginx-load-balan/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-23T03:22:00.000Z">
          2018-02-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>在现在互联网爆发的时代，稳定性成为每个项目的首选，再次条件下，我们就要实现高可用的概念，实现高可用的最常用的一种手段就是负载均衡，分摊各个服务器的请求压力。</p>
<h2 id="1-轮训（默认）"><a href="#1-轮训（默认）" class="headerlink" title="1.轮训（默认）"></a>1.轮训（默认）</h2><p>按照请求时间的循序，把请求逐一分配到对应的服务器。如果其中一台服务器 down 了，nginx 会自动剔除 down 掉的服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14;</span><br><span class="line">    server 192.168.0.15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-权重-weight"><a href="#2-权重-weight" class="headerlink" title="2.权重(weight)"></a>2.权重(weight)</h2><p>其实就是轮训的升级版，给特定的服务器一个指定的权重，nginx 会根据权重分配请求访问。一般用于服务器性能不一致的情况下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123;</span><br><span class="line">    server 192.168.0.14 weight&#x3D;3;</span><br><span class="line">    server 192.168.0.15 weight&#x3D;7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Nginx/">Nginx</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Nginx/">Nginx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/23/nginx-example/"><span>【nginx】- 常用配置例子</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/23/nginx-example/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-23T02:53:30.000Z">
          2018-02-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>以下整理一下一些 nginx 常用例子。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>目录对换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;123456&#x2F;xxxx -&gt; &#x2F;xxxx?id&#x3D;123456</span><br><span class="line"></span><br><span class="line">rewrite ^&#x2F;(\d+)&#x2F;(.+)&#x2F; &#x2F;$2?id&#x3D;$1 last;</span><br></pre></td></tr></table></figure>

<ul>
<li>例如下面设定 nginx 在用户使用 ie 的使用重定向到/nginx-ie 目录下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">  rewrite ^(.*)$ &#x2F;nginx-ie&#x2F;$1 break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Nginx/">Nginx</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Nginx/">Nginx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/23/nginx-var/"><span>【Nginx】 - 变量</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/23/nginx-var/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-23T02:26:00.000Z">
          2018-02-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Nginx配置文件管理者整个nginx服务的运作，有一些逻辑我们可以通过nginx内置变量或者自定义变量来选择性配置。</p>
<h2 id="内置常见变量参见下表："><a href="#内置常见变量参见下表：" class="headerlink" title="内置常见变量参见下表："></a>内置常见变量参见下表：</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$arg_name</td>
<td>请求中的name参数</td>
</tr>
<tr>
<td>$args</td>
<td>请求中的参数</td>
</tr>
<tr>
<td>$content_length</td>
<td>HTTP请求里面的”Content-Length”</td>
</tr>
<tr>
<td>$content_type</td>
<td>HTTP请求里面的”Content-Type”</td>
</tr>
<tr>
<td>$document_root</td>
<td>配置里面设置的 <code>root</code> 赋值</td>
</tr>
<tr>
<td>$host</td>
<td>请求信息种的”HOST”,如果请求头不存在<code>Host</code>的话，那么久等于<code>server_name</code> 赋值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>cookie信息</td>
</tr>
<tr>
<td>$http_referer</td>
<td>引用地址，就是前一个链接地址</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>客户端代理信息</td>
</tr>
<tr>
<td>$is_args</td>
<td>如果请求行带有参数，返回“？”，否则返回空字符串</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>当前连接速率的限制</td>
</tr>
<tr>
<td>$pid</td>
<td>nginx当前worker进程的PID</td>
</tr>
<tr>
<td>$query_string</td>
<td>与$args基本一致</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>客户端IP地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>客户端端口号</td>
</tr>
<tr>
<td>$scheme</td>
<td>当前所用的协议，比如http或者https</td>
</tr>
<tr>
<td>$request_method</td>
<td>请求方法，比如“GET”，“POST”等</td>
</tr>
<tr>
<td>$request_uri</td>
<td>请求的URI，带参数，比如：<code>http://localhost:8080/uuu</code></td>
</tr>
</tbody></table>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Nginx/">Nginx</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Nginx/">Nginx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/23/nginx-rewrite/"><span>【Nginx】- Rewrite功能</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/23/nginx-rewrite/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-23T01:57:00.000Z">
          2018-02-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Nginx 作为一个 http 服务器，其中最重要的一个特点就是 rewrite 功能，这个功能算是 nginx 必会内容了，接下来，我们详细说明一下 URL 重写配置以及信息详解</p>
<p>Nginx-rewrite 依赖</p>
<ul>
<li>PCRE 软件的支持，支持 perl 兼容正则表达式语句进行规则匹配</li>
</ul>
<p>rewrite 是实现 URL 重写的关键指令，根据 regex（正则表达式）部分内容，重定向到 replacement，结尾是 flag 标记。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite   &lt;regex&gt;    &lt;replacement&gt; [flag]</span><br><span class="line"></span><br><span class="line">关键字     正则表达式  替换内容       flag标记</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关键字：固定 rewrite 开启的关键字</p>
</li>
<li><p>正则：perl 兼容正则表达式语句进行规则匹配</p>
</li>
<li><p>替代内容：将正则匹配的内容替换成 replacement</p>
</li>
<li><p>flag 标记：rewrite 支持的 flag 标记</p>
</li>
</ul>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Nginx/">Nginx</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Nginx/">Nginx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/23/fulltext-mm-dmm/"><span>MM|DMM-中文全文搜索引擎</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/23/fulltext-mm-dmm/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-23T09:20:49.000Z">
          2018-01-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是中文分词</p>
<p>众所周知，英文是以 词为单位的，词和词之间是靠空格隔开，而中文是以字为单位，句子中所有的字连起来才能描述一个意思。例如，英文句子 I am a student，用中文则为：“我是一个学生”。计算机可以很简单通过空格知道 student 是一个单词，但是不能很容易明白“学”、“生”两个字合起来 才表示一个词。把中文的汉字序列切分成有意义的词，就是中文分词，有些人也称为切词。我是一个学生，分词的结果是：我 是 一个 学生。</p>
<h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h2 id="最小匹配算法"><a href="#最小匹配算法" class="headerlink" title="最小匹配算法"></a>最小匹配算法</h2>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法/">算法</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a><a href="/tags/全文搜索/">全文搜索</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/23/数据结构/trie-tree/"><span>基于tire-tree的关键字匹配</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/23/数据结构/trie-tree/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-23T07:20:00.000Z">
          2018-01-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字典树，又称前缀树或 trie 树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>早期的时候，我在 github 上写了一个，但是一直没有写博文。</p>
<p><a href="https://github.com/whiteCcinn/tire-php" target="_blank" rel="noopener">https://github.com/whiteCcinn/tire-php</a></p>
<p>当时写的时候，比较复杂，因为汉字的编码问题，里面会设置一些 ascii 码和 utf-8 编码的转码代码，看上去比较复杂。接下来，会贴一段通过正则实现的代码。</p>
<p>那么 trie 树怎么实现关键字的匹配呢? 这里以一幅图来讲解 trie 树匹配的过程。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法/">算法</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a><a href="/tags/树/">树</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/23/redis-geohash/"><span>基于geohash算法-搜索附近的人</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/23/redis-geohash/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-23T03:45:00.000Z">
          2018-01-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前空间索引的实现有 R 树和其变种 GIST 树、四叉树、网格索引等。 网格索引不再多提，使用普通的 hash 表存储地点和风格之间的映射来实现。今天要介绍的 GeoHash 算法实现的空间索引，虽然是以 B 树实现，但我认为它也借用网格索引的一部分思想。</p>
<p><a href="https://github.com/whiteCcinn/geohash" target="_blank" rel="noopener">php-geohash</a></p>
<h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><ol>
<li>从横向上将整个方形纸分为左右两份，左侧部分为标记为 <code>0</code>， 右侧部分标记为 <code>1</code>；</li>
<li>再将红点所在的部分划分为左右两块，再对红点位置做同样的标识，最后得出红点在横向上的标识为 <code>10</code>;</li>
<li>在纵向上对方形纸做同样的划分，左侧标识为<code>0</code>，右侧标识为 <code>1</code>，得出红点位置在纵向上的标识为 <code>01</code>;</li>
<li>将横向标识和纵向标识合并，规则为 纵向在奇数位，横向在偶数位 (也可纵横相反，但要在整个系统内保持一致)，得出红点在方形纸上的标识为 <code>1001</code>;</li>
</ol>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法/">算法</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/算法/">算法</a><a href="/tags/Redis/">Redis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/02/docker-php-nginx/"><span>docker安装php7+nginx事例</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/02/docker-php-nginx/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-02T01:34:00.000Z">
          2017-11-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>docker 是由 go 语言开发的的一个虚拟机容器，通过层的概念，把 fs(filesysytem)连接起来，形成一个可以独立的系统。其中涉及到了宿主机的概念，在这里，由于我所用的环境基本都是 centos7，所以这篇文章讲诉的就是 centos7 中使用 docker 安装 php7+nginx 的事例。后续我会发布一些镜像以及 dockerFile 提供大家学习参考。</p>
<blockquote>
<p>需要注意的是：docker 运动的服务都需要以前台的模式运行</p>
</blockquote>
<h1 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure>

<p>由于我们学习如何使用 docker，所以这里就选择了的直接采用 yum 安装了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="创建-docker-容器操作用户"><a href="#创建-docker-容器操作用户" class="headerlink" title="创建 docker 容器操作用户"></a>创建 docker 容器操作用户</h2><p>由于 docker 容器基于宿主机，所以我们可以在宿主机中创建好对容器操作的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; -g -u 参数分别指的的是gid，和uid</span><br><span class="line">groupadd -g 2017 docker-group</span><br><span class="line">adduser -g 2017 -u 2017 docker-user</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Docker/">Docker</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/PHP/">PHP</a><a href="/tags/Docker/">Docker</a><a href="/tags/Nginx/">Nginx</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/08/linux-make-swoole2/"><span>Centos7安装swoole2.x协程系列</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/08/linux-make-swoole2/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-08T02:47:00.000Z">
          2017-09-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于一个合格的 php 后端开发者而言，<code>swoole</code> 的知名度，估计是大家都知道的，swoole 分为 2 个系列，一个是<code>1.9.x</code>系列，一个是<code>2.x</code>系列，两个系列的区别在于<code>1.9</code>系列是原 swoole 成员研发的主分支，<code>2.x</code>系列是由腾讯成员研发的副分支。<code>1.9.x</code>系列底层原生不支持<code>协程</code>的概念，跟着 php 原生态走，但是<code>2.x</code>底层采用的是<code>协程</code>的概念进行研发，基本上需要用到网络 io 的地方在特定的情况下都会去触发<code>协程</code>，记住当前的<code>VM stack</code>的信息，然后通过<code>Eventloop</code>事件去处理别的请求，形成一个相对于原生态的阻塞的执行过程来说，这种非阻塞的处理方式，把 1+2 = 3 的 IO 时间变成了 max(1,2) =2。从而在高并发的请求下，可以更好的承载更多的请求。</p>
<p>之前我有过一篇文章说的就是安装 v2.0.5 的。但是现在重新装一次，说明一下。</p>
<h2 id="下载-git"><a href="#下载-git" class="headerlink" title="下载 git"></a>下载 git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v.2.0.9 https:&#x2F;&#x2F;github.com&#x2F;swoole&#x2F;swoole-src.git</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux/">Linux</a>, <a href="/categories/Linux/PHP/">PHP</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/PHP/">PHP</a><a href="/tags/Linux/">Linux</a><a href="/tags/Swoole/">Swoole</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/22/linux-make-tcpdump/"><span>linux-make-tcpdump</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/22/linux-make-tcpdump/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-22T10:06:24.000Z">
          2017-08-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>TCPDUMP 可以帮写我们抓包，相当于 window 下的<code>wireshark</code>，为了我们更好的深入分析，我们把 tcpdump 也安装了。</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul>
<li><a href="http://www.tcpdump.org/#latest-releases" target="_blank" rel="noopener">tcpdump-国内镜像</a></li>
</ul>
<p>找到最新版,安装 tcpdump 需要把 libpcap 也安装了.</p>
<h2 id="安装-libpcap"><a href="#安装-libpcap" class="headerlink" title="安装 libpcap"></a>安装 libpcap</h2><p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src &amp;&amp; sudo mkdir libpcap &amp;&amp; sudo wget http:&#x2F;&#x2F;www.tcpdump.org&#x2F;release&#x2F;libpcap-1.8.1.tar.gz &amp;&amp; sudo tar -zxvf &amp;&amp; sudo tar -zxvf libpcap-1.8.1.tar.gz &amp;&amp; cd libpcap-1.8.1</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/协议/">协议</a>, <a href="/categories/协议/网络/">网络</a>, <a href="/categories/协议/网络/Linux/">Linux</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/协议/">协议</a><a href="/tags/Linux/">Linux</a><a href="/tags/网络/">网络</a><a href="/tags/TcpDump/">TcpDump</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/9/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/11/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>