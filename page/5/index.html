<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 5 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/12/05/数据库开发知识/基于B+树实现一个高并发数据库/"><span>【数据库开发知识】基于B+树实现一个高并发数据库</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/12/05/数据库开发知识/基于B+树实现一个高并发数据库/" rel="bookmark">
        <time class="entry-date published" datetime="2019-12-05T09:43:43.000Z">
          2019-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (3) <span class="comment">// B+树的阶数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT_M_2 (M &gt;&gt; 1) <span class="comment">// M的中点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> True (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> False (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX_NAME (<span class="meta-string">"index"</span>) <span class="comment">// 索引文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MODE (O_RDWR | O_CREAT | O_TRUNC) <span class="comment">// 打开文件的模式：可读可写打开 | 若此文件不存在则创建它 | 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Truncate）为0字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) <span class="comment">// 文件的权限：660</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType; <span class="comment">// 关键字的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">off_t</span> Record; <span class="comment">// 索引所对应的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> isLeaf;                <span class="comment">// 是否是叶子节点</span></span><br><span class="line">	<span class="keyword">int</span> keynum;                <span class="comment">// 关键字个数</span></span><br><span class="line">	KeyType key[M + <span class="number">1</span>];        <span class="comment">// 存放的关键字的连续内存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span> *<span class="title">ptr</span>[<span class="title">M</span> + 1];</span><span class="comment">// 关键字子树的连续内存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BPTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	Record value[M + <span class="number">1</span>];       <span class="comment">// 关键字对应的value，当节点为叶子节点的时候才有效</span></span><br><span class="line">&#125;BPTNode, *BPTree;</span><br></pre></td></tr></table></figure>

<p>我们看到 <code>BPTNode</code> 是我们的节点结构体，这个结构体占用的内存大小我们计算一下：</p>
<p>记住内存对齐的原则，并且指针占用 8 个字节，off_t 一般是 64 位，占用 8 个字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4(int)+4(int)+4(KeyType)*4(M+1)+4(*pts)*4(M+1)+4(*next)+8(Record)*4(M+1) &#x3D; 4+4+16+32+8+32 &#x3D; 96bytes</span><br></pre></td></tr></table></figure>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据结构/">数据结构</a>, <a href="/categories/数据结构/数据库/">数据库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/数据库开发知识/">数据库开发知识</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/11/04/消息队列/kafka-swoole/"><span>【消息队列】- kafka-swoole</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/11/04/消息队列/kafka-swoole/" rel="bookmark">
        <time class="entry-date published" datetime="2019-11-04T02:37:40.000Z">
          2019-11-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 kafka 客户端在 php 中比较出名的仅有 2 个，这 2 个项目都有各自的利弊。在这里我选择几个来列一下</p>
<ul>
<li><a href="https://github.com/weiboad/kafka-php" target="_blank" rel="noopener">weiboad/kafka-php</a><ul>
<li>协议非结构化封装，自定义性较强，不好维护</li>
<li>目前的 API 在消费者中由于单例设计的原因，不允许在消费者中生产消息</li>
<li>不支持多种压缩协议</li>
<li>单进程“协程式”逻辑，数据未实现分离，容易堵塞消费</li>
</ul>
</li>
<li><a href="https://github.com/arnaud-lb/php-rdkafka" target="_blank" rel="noopener">arnaud-lb/php-rdkafka</a><ul>
<li>协议非结构化封装，自定义性较强，不好维护</li>
<li>不支持多种压缩协议</li>
<li>利用多线程，但是 PHP 对多线程对支持并不友好，相对于用 swoole 而言，劣势较为明显，容易出 bug，且维护性不高</li>
</ul>
</li>
</ul>
<p>基于以上几点，我们在基于<code>swoole-4.3</code>以上重新开发了<code>kafka-swoole</code>项目，优点如下：</p>
<ul>
<li>多进程多核处理</li>
<li>支持 kafka 多个 sink 方式，实现拉取 kafka 数据和业务逻辑分离，从而不堵塞数据拉取</li>
<li>首个支持多种压缩方式（normal(不压缩)/gzip/snappy）的 php 客户端，从而在大吞吐对情况下减少带宽占用，提高传输速率</li>
<li>协议封装采用 OOP 的方式，结构化了协议的封装，利于维护和封装，对协议利用反射来统一封包和解包</li>
<li>利用协程来实现单个进程中对异步逻辑处理</li>
<li>提供了 runtime 的 rpc 命令，实时获取 kafka 成员进程对内部数据，实时查看消费情况</li>
<li>提供了 kafka 命令，方便获取 kafka 服务相关信息和 kafka 相关操作</li>
<li>在成员进程挂掉的情况下，记录错误信息，自动拉起。</li>
<li>对于常驻进程，不排除业务逻辑写出了内存泄漏的情况，所以所有的子进程都带有内存临界值重启机制来释放内存</li>
<li>主进程退出的情况下，发起了<code>离开消费者组</code>的请求，使得 kafka 能快速响应消费者组最新状态，从而更好平滑重新加入消费者</li>
</ul>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/消息队列/">消息队列</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Swoole/">Swoole</a><a href="/tags/消息队列，Kafka/">消息队列，Kafka</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/10/01/消息队列/kafka/"><span>【消息队列】- Kafka相关</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/10/01/消息队列/kafka/" rel="bookmark">
        <time class="entry-date published" datetime="2019-10-01T07:25:40.000Z">
          2019-10-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 kafka 客户端在 php 中比较出名的仅有 2 个，但是其各有利弊，在这里就不展开详细说明了。因此，我们实现了一个叫<code>kafka-swoole</code>的项目，项目由<code>swoole4.x</code>协程+多进程实现，实现在串行化协程的基础上实现并行操作。</p>
<p>由于很多小伙伴对 kafka 并不是特别了解，所以在这里记录一下一些基础的 kafka 自带的命令使用方式</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/消息队列/">消息队列</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/消息队列，Kafka/">消息队列，Kafka</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/08/12/大数据/Glow源码剖析/"><span>【大数据】- Glow 源码剖析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/12/大数据/Glow源码剖析/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-11T16:07:40.000Z">
          2019-08-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>犹豫公司的流式计算，并没有用类似于 Hadoop 的 mapreduce 机制或者 storm 或者 flink，是我们自研基于 erlang 的单节点服务，其优点就是：部署和迁移都十分简单，并且犹豫 erlang 的天然的良好的利用了多核 CPU 的优势，可以实现效率较高的大数据流式计算。但是由于其单机性，导致对单台机器的要求过于苛刻，并且不能进行扩展机器提高计算能力是其致命的缺点，所以目前我规划利用 golang，写一个支持分布式并行计算的服务，在此之前，了解了各大流式计算的基本思想，并且结合 golang 语言的特性，找到了一个叫<code>glow</code>的服务，想要写好一个分布式流式计算的服务，我们先来看看 <code>glow</code> 有什么好的借鉴的思想和思路。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/大数据/">大数据</a>, <a href="/categories/大数据/Golang/">Golang</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Golang/">Golang</a><a href="/tags/大数据，流式计算/">大数据，流式计算</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/08/07/网络协议/TCP-tcpdump/"><span>【网络协议】TCP - tcpdump用法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/07/网络协议/TCP-tcpdump/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-07T07:57:13.000Z">
          2019-08-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于我们在服务器上编程或者调试的时候，都不可能是各种抓包客户端，所以我们需要学会运用 tcpdump 来对网络的数据进行抓包。<br>用简单的话来定义 tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump 可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句来帮助你去掉无用的信息。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络协议/">网络协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP/">TCP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/08/07/网络协议/TCP-重传机制/"><span>【网络协议】TCP - 重传机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/07/网络协议/TCP-重传机制/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-07T03:33:40.000Z">
          2019-08-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>其中涉及 ACK 包比较关键，因为在窗口的这篇文章中，已经说过了，ACK 机制起始就是类似于一种反馈机制。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络协议/">网络协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP/">TCP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/08/06/网络协议/TCP-窗口/"><span>【网络协议】TCP 窗口</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/06/网络协议/TCP-窗口/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-06T09:43:43.000Z">
          2019-08-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近写了一篇关于 TCP 协议的文章，所以一些更加细节的内容，更偏向 TCP 独立协议的，拿出来独立记录。</p>
<p>为了获得最优的连接速率，使用 TCP 窗口来控制流速率（flow control），滑动窗口就是一种主要的机制。这个窗口允许源端在给定连接传送数据分段而不用等待目标端返回 ACK，一句话描述：窗口的大小决定在不需要对端响应（acknowledgement）情况下传送数据的数量。​ 官方定义：“The amount of octets that can be transmitted without receiving an acknowledgement from the other side”。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络协议/">网络协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP/">TCP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/08/06/网络协议/TCP-IP/"><span>【网络协议】TCP/IP协议</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/06/网络协议/TCP-IP/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-06T02:43:43.000Z">
          2019-08-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近看了 Redis5 的源码，所以对网络编程又进一步加深了了解，在这里，由于没有很系统的整理过 TCP/IP 协议相关的内容，所以写下这篇文章，以此来记录我最近学习到的内容，内容会分为以下几个方面。</p>
<ul>
<li>TCP/IP 协议，三次握手，四次挥手，协议细节</li>
<li>协议相关的细节，优化调整内核参数</li>
<li>模拟异常连接，优化调整内核参数</li>
<li>利用 C 语言，基于 epoll 写一个支持高并发的 TCP 聊天服务器</li>
</ul>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/网络协议/">网络协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/TCP/">TCP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/10/源码剖析/redis5源码剖析/"><span>【源码剖析】Redis主流程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/10/源码剖析/redis5源码剖析/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-10T02:43:43.000Z">
          2019-07-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 main 函数开始，沿着代码执行路径，实际上我们可以一直追下去。但为了让本文不至于太过冗长，我们还是限定一下范围。本文的目标就定为：引领读者从 main 函数开始，一步步追踪下去，最终到达任一 Redis 命令的执行入口。</p>
<p>后续，再剖析各个命令的内部实现</p>
<blockquote>
<p>本文基于 redis5.0 分支</p>
</blockquote>
<p>为了表述清楚，本文按照如下思路进行：</p>
<ul>
<li>先概括地介绍整个代码初始化流程（从 main 函数开始）和事件循环的结构；</li>
<li>再概括地介绍对于 Redis 命令请求的处理流程；</li>
<li>重点介绍事件机制；</li>
<li>对于前面介绍的各个代码处理流程，给出详细的代码调用关系，方便随时查阅；</li>
</ul>
<p>根据这样几部分的划分，如果你只想粗读大致的处理流程，那么只需要阅读前两个部分就可以了。而后两部分则会深入到某些值得关注的细节。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Redis/">Redis</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Redis，源码剖析/">Redis，源码剖析</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/09/数据结构/二叉树/"><span>【数据结构】二叉树</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/09/数据结构/二叉树/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-09T07:20:00.000Z">
          2019-07-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3 树、红黑树等等。本文中对数据结构中常见的几种树的概念和用途进行了汇总，不求严格精准，但求简单易懂。</p>
<p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p>
<p>二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于 2 的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2^(i-1) 个结点；深度为 k 的二叉树至多有 (2^k)-1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0=n2+1。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/数据结构/">数据结构</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/数据结构/">数据结构</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/4/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/6/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>