<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 12 | 白菜君の技术库</title>

  
  <meta name="author" content="白菜(whiteCcinn)">
  

  
  <meta name="description" content="知道做不到，等于不知道">
  

  
  <meta name="keywords" content="白菜,文辉,技术博客,whiteCcinn">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="白菜君の技术库"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="白菜君の技术库" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">白菜君の技术库</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">文章</a></li>
      
        <li><a href="/tags/">标签</a></li>
      
        <li><a href="/categories/">分类</a></li>
      
        <li><a href="/about/">关于我</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/27/ascii-code-2/"><span>字符编码深度剖析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/27/ascii-code-2/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-27T14:44:00.000Z">
          2017-07-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这里，我们对如下4种编码进行对比</p>
<ul>
<li>unicode编码</li>
<li>utf8编码</li>
<li>ascii编码</li>
<li>asni编码</li>
</ul>
<h3 id="ASCII编码和ASNI编码的区别"><a href="#ASCII编码和ASNI编码的区别" class="headerlink" title="ASCII编码和ASNI编码的区别"></a>ASCII编码和ASNI编码的区别</h3><p>字符内码(charcter code)指的是用来代表字符的内码.读者在输入和存储文档时都要使用内码,内码分为 单字节内码 – Single-Byte character sets (SBCS),可以支持<strong>255</strong>（ <code>8bits = (2^8)-1 = 255</code>）个字符编码. 双字节内码 – Double-Byte character sets)(DBCS),可以支持<strong>65000</strong>个字符编码（最多支持<code>16 bits = (2^16)-1 = 65535</code>）. 前者即为ASCII编码，后者对应ANSI. 至于简体中文编码GB2312，实际上它是ANSI的一个代码页</p>
<h3 id="UNICODE编码"><a href="#UNICODE编码" class="headerlink" title="UNICODE编码"></a>UNICODE编码</h3><p>unicode 是一种编码表格，例如，给一个汉字规定一个代码。类似 GB2312-1980, GB18030等，只不过字集不同。 一个unicode码可能转成长度为一个BYTE,或两个，三个，四个BYTE（<code>最多6个byte</code>）的UTF8码，取决于unicode码的值。英文unicode码因为值小于<strong>0x80</strong>（<code>单字节字符</code>）,只要用一个BYTE的UTF8传送，<code>比送unicode两个bytes快</code>。</p>
<p>如上，ANSI有很多代码页，使用不同代码页的内码无法在其他代码也正常显示，这就是为什么日文版／繁体中文版游戏无法在简体中文平台直接显示的原因．</p>
<p>Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳<strong>全世界所有语言文字的编码方案</strong>．它是一种<code>２字节编码</code>，能够提供６５５３５个字符， 这个数字是<strong>不够表示所有的字符</strong>的（汉语就有５５０００多字符），所以，通过一个代理对的机制来实现附加的９１７，４７６个字符表示，以达到所有字符都具有<code>唯一编码</code>．</p>
<h3 id="Unicode和BigEndianUnicode"><a href="#Unicode和BigEndianUnicode" class="headerlink" title="Unicode和BigEndianUnicode"></a>Unicode和BigEndianUnicode</h3><p>这两者只是存储顺序不同，如＂A＂的unicode编码为65 00 其BigEndianUnicode编码为00 65</p>
<p>其实就是类比于我之前说过的大小端的介绍</p>
<h3 id="UTF8编码"><a href="#UTF8编码" class="headerlink" title="UTF8编码"></a>UTF8编码</h3><p>UTF8全称：Unicode Transformation Format – 8 bit（unicode转化格式为8位的流数据）</p>
<p>Unicode是一个字符集，而UTF-8是Unicode的其中一种，Unicode是定长的都为双字节，而UTF-8是可变的，对于汉字来说Unicode占有的字节比UTF-8占用的字节少1个字节。Unicode为双字节，而UTF-8中汉字占三个字节。</p>
<p>是Unicode传送格式。即把Unicode文件转换成BYTE的传送流。</p>
<p>其中UTF-16和Unicode编码大致一样, UTF-8就是以8位为单元对Unicode进行编码。</p>
<p>UTF-8编码字符理论上可以最多到6个字节长,然而<code>16位BMP（Basic Multilingual Plane）字符</code>最多只用到3字节长。从Unicode到UTF-8的编码方式如下：</p>
<table>
<thead>
<tr>
<th>Unicode编码(16进制)</th>
<th>UTF-8 字节流(二进制)</th>
</tr>
</thead>
<tbody><tr>
<td>0000 - 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0080 - 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0800 - FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>100000 - 1FFFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>200000 - 3FFFFFF</td>
<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>4000000 - 7FFFFFFF</td>
<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>例如“我”字的Unicode编码是4f6b。4f6b在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将4f6b写成二进制是：100 111101 101011， 用这个比特流依次代替模板中的x，得到：11100100 10111101 10101011，即E4 9C AB。</p>
<h3 id="用PHP实现unicode编码和utf8编码的转变"><a href="#用PHP实现unicode编码和utf8编码的转变" class="headerlink" title="用PHP实现unicode编码和utf8编码的转变"></a>用PHP实现unicode编码和utf8编码的转变</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UTF-8编码字符理论上可以最多到6个字节长,然而16位BMP（Basic Multilingual Plane）字符最多只用到3字节长。下面看一下UTF-8编码表：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * U-00000000 - U-0000007F: 0xxxxxxx</span></span><br><span class="line"><span class="comment"> * U-00000080 - U-000007FF: 110xxxxx 10xxxxxx</span></span><br><span class="line"><span class="comment"> * U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line"><span class="comment"> * U-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line"><span class="comment"> * U-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line"><span class="comment"> * U-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单字符汉字转换unicode(16进制)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $utf8_str</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">utf8_transform_unicode</span><span class="params">($utf8_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  $unicode = (ord($utf8_str&#123;<span class="number">0</span>&#125;) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">12</span>;</span><br><span class="line">  $unicode |= (ord($utf8_str&#123;<span class="number">1</span>&#125;) &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">  $unicode |= (ord($utf8_str&#123;<span class="number">2</span>&#125;) &amp; <span class="number">0x3F</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dechex($unicode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unicode编码转汉字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $unicode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unicode_transform_utf8</span><span class="params">($unicode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 十六进制转十进制</span></span><br><span class="line">  $unicode  = (int)hexdec($unicode);</span><br><span class="line">  $ord_1    = decbin(<span class="number">0xe0</span> | ($unicode &gt;&gt; <span class="number">12</span>));</span><br><span class="line">  $ord_2    = decbin(<span class="number">0x80</span> | (($unicode &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">  $ord_3    = decbin(<span class="number">0x80</span> | ($unicode &amp; <span class="number">0x3f</span>));</span><br><span class="line">  $utf8_str = chr(bindec($ord_1)) . chr(bindec($ord_2)) . chr(bindec($ord_3));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> $utf8_str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$str = <span class="string">'我'</span>;</span><br><span class="line"><span class="keyword">echo</span> utf8_transform_unicode($str);</span><br><span class="line"></span><br><span class="line">$unicode = <span class="string">'6211'</span>;</span><br><span class="line"><span class="keyword">echo</span> unicode_transform_utf8($unicode);</span><br></pre></td></tr></table></figure>

<p>后续，我会出一个用php直接实现编码转换和汉字字符串截取的PHP扩展，都会用到这次的知识，后续见。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/协议/">协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/协议/">协议</a><a href="/tags/ascii/">ascii</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/27/ccp/"><span>PHP 实现 Promise+协程调用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/27/ccp/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-27T14:13:00.000Z">
          2017-07-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <ul>
<li>PHP 实现 Promise+协程调用</li>
</ul>
<p>github 地址：<a href="https://github.com/whiteCcinn/ccp" target="_blank" rel="noopener">ccp</a></p>
<blockquote>
<p>觉得好记的给个 Start 喔。</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在 PHP 当中，我们或多或少会使用到异步编程的思想，但是异步编程难免给我们带来回调地狱的感觉，并且代码可读性十分之差，在 ES6 规范里面，或者更早就可以推出了一个做 Promise 的东西，利用 Promise，你可以用同步的做法来实现异步的操作，代码可读性上大大提高，不仅如此，由于异步编程和异步 IO 的混合使用，导致代码的准确性难以提高，不可否认的是，Promise 的推出，大大的提高了你们编写异步代码的可靠性，虽然这也是会损耗一些十分微小的性能，但是任何取舍都是相对的。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/PHP/">PHP</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/PHP/">PHP</a><a href="/tags/Promise/">Promise</a><a href="/tags/ES6/">ES6</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/13/id-sender/"><span>64位分布式自增发号器</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/13/id-sender/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-13T09:30:00.000Z">
          2017-07-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="IdCenterSender-—PHP-源码实现-64-位分布式自增发号器"><a href="#IdCenterSender-—PHP-源码实现-64-位分布式自增发号器" class="headerlink" title="IdCenterSender —PHP 源码实现-64 位分布式自增发号器"></a>IdCenterSender —PHP 源码实现-64 位分布式自增发号器</h2><p>PHP 实现 64 位分布式 ID 发号器, github 上也有 C 语言版本上的连接可以进去跳转</p>
<p><a href="https://github.com/whiteCcinn/IdCenterSender" target="_blank" rel="noopener">github 地址 : IdCenterSender</a></p>
<blockquote>
<p>觉得好记的给个 Start 喔。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>参考 Snowflake 算法,根据自身设计情况扩展了其中的细节</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/算法/">算法</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/C/">C</a><a href="/tags/PHP/">PHP</a><a href="/tags/算法/">算法</a><a href="/tags/ID发号器/">ID发号器</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/11/rabbit-mq/"><span>RabbitMQの关键知识整理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/11/rabbit-mq/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-11T03:45:00.000Z">
          2017-07-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>RabbitMQ 作为一个转发服务器，里面涉及了一些实体的东西，如下：</p>
<ul>
<li>生产者 (Producter)</li>
<li>消息 (Message)</li>
<li>交换机 (Exchange)</li>
<li>队列 (Queue)</li>
<li>消费者 (Consumer)</li>
</ul>
<p>在这些实体的东西的基础上，RabbitMQ 重点的是 <code>交换机</code>,<code>队列</code></p>
<h3 id="交换机与队列"><a href="#交换机与队列" class="headerlink" title="交换机与队列"></a>交换机与队列</h3><p>说完实体的东西之后，在 <code>交换机</code> 和 <code>队列</code> 之间有许多的规则（玩法），我们增加了如下内容：</p>
<ul>
<li><p>队列名 (Queue_name)</p>
</li>
<li><p>交换机类型 (Exchange_type)</p>
</li>
<li><p>路由键 (Routing_key)</p>
</li>
</ul>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/MQ/">MQ</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/MQ/">MQ</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/28/network-protocol-endian/"><span>大端和小端（Big endian and Little endian）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/28/network-protocol-endian/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-28T06:43:00.000Z">
          2017-06-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="大端和小端（Big-endian-and-Little-endian）"><a href="#大端和小端（Big-endian-and-Little-endian）" class="headerlink" title="大端和小端（Big endian and Little endian）"></a>大端和小端（Big endian and Little endian）</h1><h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</p>
<p>由此可知，网络字节序是大端序的。那么什么是Big endian呢？</p>
<h2 id="一、大端和小端的问题"><a href="#一、大端和小端的问题" class="headerlink" title="一、大端和小端的问题"></a>一、大端和小端的问题</h2><p>对于整型、长整型等数据类型，Big endian 认为第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）；而 Little endian 则相反，它认为第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）。</p>
<p><strong>例如，假设从内存地址 <code>0x0000</code> 开始有以下数据：</strong></p>
<table>
<thead>
<tr>
<th>0x0000</th>
<th>0x0001</th>
<th>0x0002</th>
<th>0x0003</th>
</tr>
</thead>
<tbody><tr>
<td>0x12</td>
<td>0x34</td>
<td>0xab</td>
<td>0xcd</td>
</tr>
</tbody></table>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/协议/">协议</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/协议/">协议</a><a href="/tags/进制/">进制</a><a href="/tags/网络/">网络</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/28/bin-hex-oct/"><span>进制转换相关知识</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/28/bin-hex-oct/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-28T02:43:00.000Z">
          2017-06-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><blockquote>
<p>好久都没有好好整理过进制之间转换的关系了。最近在研究 RPC 的内容，有一些理论知识必须要重新整理一下。</p>
</blockquote>
<p>由于数据在计算机中的表示，最终以二进制的形式存在，所以有时候使用二进制，可以更直观地解决问题。</p>
<p>但是有一些时候，二进制表示的数据实在的太长了，所以我们可能需要一些更高进制的数来表示数据，而我们从小学习的数学，就是以 10 进制来代表的。</p>
<p><strong>进制数越大，所需要数长度就越短。</strong></p>
<p>我们常用的进制有 2、8、16 进制，分别是 2 的 1 一次方，2 的 3 次方，2 的 4 次方。（至于为什么没有 3 进制，4 进制诸如此类的，各位百度一下吧）</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/进制/">进制</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/进制/">进制</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/22/design-strategy-model/"><span>设计模式の行为型の策略模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/22/design-strategy-model/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-22T07:23:00.000Z">
          2017-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>策略模式是一个非常常用，且非常有用的设计模式。<br>简单的说，它是当你使用大量 if else 逻辑时的救星。<br>if else 就是一种判断上下文的环境所作出的策略，如果你把 if else 写死，那么在复杂逻辑的时候你会发现代码超级长，而且最蛋疼的是，当你以后要新增策略时，再写一个 elseif？<br>万一这个逻辑要修改 20 个地方呢？<br>一口老血吐在屏幕上…<br>策略模式就是来解决这个问题的。<br>举一个场景，商城的首页，男的进来看男性商品，女的进来看女性商品，不男不女…以此类推，各种条件下用不同策略展示不同商品。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/设计模式/">设计模式</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式，PHP/">设计模式，PHP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/22/design-chain-of-responsibility-model/"><span>设计模式の行为型の责任链模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/22/design-chain-of-responsibility-model/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-22T07:06:00.000Z">
          2017-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="理解概念"><a href="#理解概念" class="headerlink" title="理解概念"></a>理解概念</h1><p>责任链是一种比较高级的行为设计模式，就是当你有一个请求，你不知道用那个方法(handler)来处理这个请求时，你可以把这个请求丢进一个责任链里（里面有很多方法），这个责任链会通过轮询的方式自动找到对应的方法。</p>
<p>比如我要翻译一个单词，我写这个代码的时候，根本不知道用户会输入什么语言，所以我干脆就不管了，无论用户输入什么语言，我把它输入的内容丢进一个责任链，这个责任链里有德语翻译器，英语翻译器，法语翻译器，汉语翻译器，日语翻译器等等等等，丢进去的时候它就会自动查找了，找到对应的语言就会自动翻译出来。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/设计模式/">设计模式</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/PHP/">PHP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/22/design-observer-model/"><span>设计模式の行为型の观察者模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/22/design-observer-model/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-22T06:26:45.000Z">
          2017-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="大概说明"><a href="#大概说明" class="headerlink" title="大概说明"></a>大概说明</h1><p>如果我希望一个动作在发生的时候，希望订阅他这个动作的所有人都知道了有这么一件事的话，那么就采用观察者模式。</p>
<h2 id="没用观察者模式的情况下"><a href="#没用观察者模式的情况下" class="headerlink" title="没用观察者模式的情况下"></a>没用观察者模式的情况下</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Event update!&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体更新逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"update1&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"update2&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">$event = <span class="keyword">new</span> Event;</span><br><span class="line"></span><br><span class="line">$event-&gt;trigger();</span><br></pre></td></tr></table></figure>

<p>这个事件的触发可以看到如果我不断的有新的人需要订阅的话，那么这个 <code>trigger</code> 方法不断的就是要添加新的逻辑和业务。违反了设计模式-开闭原则，就是对修改关闭，对扩展开放的原则。</p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/设计模式/">设计模式</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/PHP/">PHP</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/06/22/design-d-p-d-model/"><span>设计模式の装饰器模式和观察者模式的区别</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/06/22/design-d-p-d-model/" rel="bookmark">
        <time class="entry-date published" datetime="2017-06-22T06:18:00.000Z">
          2017-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式完美的将观察者和被观察对象分开，系统中的每个类将重点放在某一个功能上，而不是其他的方面（对象之间的交互），很好的体现了单一职责原则。观察者将自己注册到被观察者的容器中，被观察者不应该过问观察者的具体类型，而是使用观察者的接口。这样的优点是：假定程序中还有别的观察者，那么这个观察者是相同的接口即可，基于接口而不是具体的实现，这一点为程序提供了更大的灵活性。</p>
<p>现实生活中像移动的就业信息推送系统，希望得到业务的人（观察者）先到移动注册，然后如果有具体的信息，移动会主动的推送到预订业务的人，不需要预订业务的人去主动询问。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式不在不改变原类文件的情况下动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。当我们需要为某个对象动态地增加一个功能的或职责的时候，可以考虑使用装饰者模式；当某个对象的职责经常发生变化或者经常需要动态的增加职责，避免为了适应变化而增加爱继承子类扩展的方式，因为这种扩展可能会造成子类膨胀的速度过快，难以控制，此时可以使用装饰着模式。</p>
<p>对于这中模式的实现，会有被装饰的具体对象，被装饰的抽象，装饰者的抽象，和若干个装饰着，这若干个装饰者并不是创建各种不同的对象（所以装饰者模式为结构型模式而不是创建型模式），而是每个装饰者都会有一个真实的对象的引用，然后在这个具体对象方法的前后添加一些新的功能，起到装饰的作用。例如有两个装饰 1，和装饰 2，那么可以把装饰 1 当作装饰 2 的具体对象作为参数传进去，这个时候就会产生另外一种新的装饰了，而且没有新的子类。</p>
<p>现实生活着的例子例如包饺子，步骤分为和陷，和面，杆皮，包饺子，煮饺子，可以在和陷这个方法的前面多加点配菜，也可以在和面这个方法的前面在面里面加个鸡蛋，也可以同时用这两个装饰先加菜后和面加鸡蛋，这样就可以用两个已经存在的装饰产生一个新的装饰了。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/设计模式/">设计模式</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/11/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/13/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 白菜(whiteCcinn)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>